void add(int n1, int n2) {
  print(n1 + n2);
}

// Dart는 오버로딩을 지원하지 않는다.
/*
void add(int n1, int n2, int n3) {
  print(n1 + n2 + n3);
}
*/

// 매개변수 타입 생략 가능 -> dynamic 타입으로 타입추론을 한다. (dynamic n1, dynamic n2) 가 되는 것이다.

// var는 타입 추론을 하여 처음 들어오는 변수의 타입으로 고정된다. 이후 다른 타입의 값이 들어올 수 없다. var타입은 Dart에서 컴파일 시점에 할당된 값에 따라 타입이 고정. (변경 불가)
// dynamic은 타입 추론을 하여 처음 들어오는 변수의 타입으로 설정되지만 이후 다른 타입의 값이 들어올 수 있다. dynamic 타입은 Dart에서 런타임 시 타입이 결정. dynamic 변수는 들어오는 값에 따라 타입이 계속 바뀔 수 있다.
// 즉, var은 컴파일 시점에 타입이 고정되기 때문에 런타임에서 타입이 결정되는 매개변수에서는 사용될 수 없는 것이다.  매개변수에는 dynamic으로 타입 추론!

// var 타입이 고정이라는 것은 var a = 1;  이렇게 a에 int값을 넣으면 그 시점에 a는 int 타입으로 고정돼서 그 뒤에 a = "하이";  이렇게 a에 int가 아닌 String 타입 못 넣음
// dynamic 타입이 바뀔 수 있다는 것은 a = 1; 이렇게 a에 int값이 들어와도 그 뒤에 a = "하이"; 이렇게 String 타입이 들어오면 변수 a는 마지막에 들어온 String 타입이 된다.
void check(a, b) {
  //dynamic으로 타입추론을 하기 때문에 b에 String이 들어와도 b=1;을 해주면 int로 바뀜
  b = 1;
  print("${a}, ${b}");
}

// var은 타입이 없기 때문에 리턴타입이 될 수 없다. var는 변수 선언에서만 사용 가능하다.
// dynamic은 Object 타입이기 때문에 dynamic은 리턴타입이 될 수 있다.
// int를 적으면 리턴 타입을 명시
int minus(n1, n2) {
  return n1 - n2;
}

// 익명 함수.
// 익명 함수는 리턴을 할 수도 있고 안 할 수도 있다.
// 변수에 함수를 넣을 때나 일회성으로 사용할 때는 함수의 리턴 타입과 함수 이름을 지우고 익명함수의 형태로 사용한다.
// int multi(n1, n2) { //코드 }  ->   (n1, n2) { //코드  }  이렇게 함수의 리턴 타입과 함수 이름을 지우고 변수에 넣는다.
// Function f = (n1, n2) { //코드 };   이렇게 변수 f를 선언하고 함수를 넣어 초기화 시키는 변수의 선언&초기화 식이기 때문에 끝에 세미콜론을 붙임
// f가 f(n1, n2) { return n1 * n2 } 가 되는 것 -> f(3,5) 이런식으로 호출
// 이때 리턴 타입과 함수 이름을 지웠기 때문에 타입이 정해져 있지 않는데 리턴 타입이 정해져 있지 않을 때는 dynamic 타입이 리턴 타입이 되고
// n1과 n2는 매개변수 이므로 dynamic 타입으로 타입추론을 한다. (위에 check() 참고)
Function f = (n1, n2) {
  return n1 * n2;
};

// 람다 표현식
// 람다는 한 줄로만 표현할 수 있다. 한 줄로 표현할 때는 중괄호와 리턴을 생략 가능하다.
// 두 줄 이상으로 표현할 때는 중괄호와 리턴을 생략할 수 없고 익명 함수 형태를 사용해야 한다.
// f2에 결과값이 들어가는 것이 아니고 식 자체가 들어가는 것이다.
// f2(a, b); 를 하면 a, b를 전달해서 a * b가 리턴되는 것
Function f2 = (n1, n2) => n1 * n2;

// 람다 표현식 중 안 좋은 문법. 사용하지 않는다.
// n1, n2가 print(n1 + n2)로 전달될 때 print가 실행되서 n1 + n2는 출력 되는데
// print자체가 return값이 없어서 이를 호출한 f3(a,b);의 결과는 null값이 된다.
// 즉 print할 때만 출력하고 실제 리턴값은 null이 되는 것
Function f3 = (n1, n2) => print(n1 + n2);

void main() {
  add(1, 2);

  add(2, 3);

  check("가", "나");

  int result = minus(9, 2);
  print(result);

  print(f(2, 3));

  print(f2(4, 6));

  //결과는 print(n1 + n2)가 실행될 때는 작동해서 10이 나오는데 print(n1 + n2)는 리턴이 없으므로 즉 f2(4,6)은 null이 된다. print(f2(4,6))은 결국 print(null)이다.
  print(f3(6, 7));
}
