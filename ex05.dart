void add(int n1, int n2) {
  print(n1 + n2);
}

// Dart는 오버로딩을 지원하지 않는다.
/*
void add(int n1, int n2, int n3) {
  print(n1 + n2 + n3);
}
*/

// 매개변수 타입 생략 가능 -> dynamic 타입으로 타입추론을 한다. (dynamic n1, dynamic n2) 가 되는 것이다.

// var는 컴파일 타임에 타입이 고정되며, 최초에 할당된 값에 따라 타입이 결정되고 이후 다른 타입의 값이 들어올 수 없다. (타입 변경 불가)
// dynamic은 타입 추론을 하여 처음 들어오는 변수의 타입으로 설정되지만 이후 다른 타입의 값이 들어올 수 있다. dynamic 타입은 Dart에서 런타임 시 타입이 결정. dynamic 변수는 들어오는 값에 따라 타입이 계속 바뀔 수 있다.
// dynamic은 런타임에 타입이 결정되며, 다른 타입의 값으로 변경될 수 있다.
// Dart에서 매개변수 타입을 명시하지 않으면 dynamic타입으로 간주!
// 마찬가지로 익명 함수에서 리턴 타입을 명시하지 않으면 리턴 타입을 dynamic으로 타입 추론한다.

//협업할 때는 매개변수 타입을 명시해주는 것이 좋다. 없으면 일일이 찾아봐야 한다.

void check(a, b) {
  //dynamic으로 타입추론을 하기 때문에 b에 String이 들어와도 b=1;을 해주면 int로 바뀜
  b = 1;
  print("${a}, ${b}");
}

// var은 타입이 없기 때문에 리턴타입이 될 수 없다. var는 변수 선언에서만 사용 가능하다.
// dynamic은 모든 타입을 수용하는 특성을 가진 타입이기 때문에(오브젝트 타입) 리턴타입이 될 수 있다.
// int를 적으면 리턴 타입을 명시하기 때문에 int값이 리턴돼야 한다.
int minus(n1, n2) {
  return n1 - n2;
}

// 익명 함수.
// 익명 함수는 리턴을 할 수도 있고 안 할 수도 있다.
// 변수에 함수를 넣을 때나 일회성으로 사용할 때는 함수의 리턴 타입과 함수 이름을 지우고 익명함수의 형태로 사용한다.
// int multi(n1, n2) { //코드 }  ->   (n1, n2) { //코드  }  이런 식으로 함수의 리턴 타입과 함수 이름을 지우고 사용.
// Function f = (n1, n2) { //코드 };   이렇게 변수 f를 선언하고 함수를 넣어 초기화 시키는, 변수의 선언&초기화 식이기 때문에 끝에 세미콜론을 붙임
// f가 f(n1, n2) { return n1 * n2 } 가 되는 것 -> f(3,5) 이런식으로 호출
// 이때 리턴 타입과 함수 이름을 지웠기 때문에 타입이 정해져 있지 않는데 리턴 타입이 정해져 있지 않을 때는 dynamic이 리턴 타입이 되고
// n1과 n2는 매개변수에 타입이 생략됐으므로 dynamic 타입으로 타입추론을 한다. (위에 check() 참고)
Function f = (n1, n2) {
  return n1 * n2;
};

// 람다 표현식
// 한 줄로 표현할 때는 중괄호와 리턴을 생략 가능하다.
// 두 줄 이상으로 표현할 때는 중괄호와 리턴을 생략할 수 없고 중괄호와 리턴을 반드시 표시해야 한다.
// 그렇기 때문에 람다식의 간결한 표현은 코드가 한 줄일 때만 쓴다.
// f2에 결과값이 들어가는 것이 아니고 변수에 함수 식이 들어가는 것이다.
// f2(a, b); 를 하면 a, b를 전달해서 a * b가 리턴되는 것
Function f2 = (n1, n2) => n1 * n2;

// 람다 표현식 중 안 좋은 문법. 사용하지 않는다.
// n1, n2가 print(n1 + n2)로 전달될 때 print가 실행되서 n1 + n2는 출력 되는데
// print자체가 return값이 없어서 이를 호출한 f3(a,b);의 결과는 null값이 된다.
// 즉 print할 때만 출력하고 실제 리턴값은 null이 되는 것  (void라고 하는데 나는 null이 뜬다.)
Function f3 = (n1, n2) => print(n1 + n2);

//람다와 익명 함수 둘 다 사실상 익명 함수로 분류되지만, 람다식은 간결한 형태의 익명 함수이다.
//즉, 람다와 익명 함수의 차이는 구문상의 차이일 뿐, 본질적으로는 둘 다 동일한 개념입니다.

void main() {
  add(1, 2);

  add(2, 3);

  check("가", "나");

  int result = minus(9, 2);
  print(result);

  print(f(2, 3));

  print(f2(4, 6));

  //결과는 print(n1 + n2)가 실행될 때는 작동해서 10이 나오는데 print(n1 + n2)는 리턴이 없으므로 즉 f2(4,6)은 null이 된다. print(f2(4,6))은 결국 print(null)이다.
  print(f3(6, 7));
}
